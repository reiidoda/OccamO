from __future__ import annotations

from dataclasses import dataclass


@dataclass(frozen=True)
class ModuleSpec:
    functions: int
    loop_depth: int
    recursion_every: int = 0
    comprehension_every: int = 0


def _indent(lines: list[str], level: int) -> list[str]:
    prefix = "    " * level
    return [f"{prefix}{line}" for line in lines]


def generate_function(
    name: str,
    loop_depth: int,
    recursion: bool = False,
    comprehension: bool = False,
) -> list[str]:
    lines = [f"def {name}(n):", "    total = 0"]
    if recursion:
        lines.extend(
            [
                "    if n <= 1:",
                "        return n",
                f"    return {name}(n - 1) + {name}(n - 2)",
            ]
        )
        return lines

    if loop_depth <= 0:
        lines.append("    total += n")
    else:
        loop_vars = [f"i{idx}" for idx in range(loop_depth)]
        lines.append(f"    for {loop_vars[0]} in range(n):")
        indent = 2
        for var in loop_vars[1:]:
            lines.append(f"{'    ' * indent}for {var} in range(n):")
            indent += 1
        lines.append(f"{'    ' * indent}total += {' + '.join(loop_vars)}")

    if comprehension:
        lines.append("    total += sum([i for i in range(n)])")

    lines.append("    return total")
    return lines


def generate_module(spec: ModuleSpec) -> str:
    lines: list[str] = ["# Generated by occamo-bench", ""]
    for idx in range(spec.functions):
        recursion = spec.recursion_every > 0 and idx % spec.recursion_every == 0
        comprehension = spec.comprehension_every > 0 and idx % spec.comprehension_every == 0
        fn_lines = generate_function(
            name=f"func_{idx}",
            loop_depth=spec.loop_depth,
            recursion=recursion,
            comprehension=comprehension,
        )
        lines.extend(fn_lines)
        lines.append("")
    return "\n".join(lines).rstrip() + "\n"
